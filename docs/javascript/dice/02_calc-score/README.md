# スコア計算について

ここでは下記について記述する。

- 関数化した場合の引数と返り値
- 各役の名前と、それを判定するための仕組み
- 各役の計算

注意：役の重複と優先度を考慮に入れる必要があるかも？  
例えば *l_straight* は *s_straight* を必ず満たす。ならば、*s_straight* を先に判定し、これを満たさなければ *l_straight* は判定不要である。この辺りをベン図で纏めとくといいかも？

## フロー

関数にした際、受け取る引数は `11235` のような整形された五桁の数値とする。
「整形された」というのは各桁の数で並び替えられている状態のことで、例えば `51321` なら `11235` となる。

返り値としては、`11235` の場合、下記のような「点数と役名がセットになった配列」を考えている。

```javascript
[
  [12, 'chance'],
  [2, 'aces'],
  [2, 'twos'],
  [3, 'threes'],
  [0, 'fours'],
  [5, 'fives'],
  [0, 'sixes'],
  [0, 'full house'],
  [0, 'three of a kind'],
  [0, 'four of a kind'],
  [0, 'yahtzee'],
  [0, 'short straight'],
  [0, 'long straight'],
]
```

返り値を受け取った側は、確定した役とその点数を入れた多次元配列を持っていることを想定している。
（空の状態から確定した分を `push()` していく形）

そこにある役名と関数で得た上記配列を比較し、既に確定分は除去して、役をプレイヤーに選択させる形になる。

### 関数呼び出し時

5桁の数値を受け取り、処理開始

### 前処理フロー

数値を各桁毎の配列に変換する。
種類と数を見るための `set` 型も用意。

### 役の判定フロー

Booleanを入れる配列を用意（全ての役の判定を格納）。
アッパーとロウワーの役を判定しながら埋めていく。

### 点数計算フロー

前述のBoolean配列と同じ要素数分のint配列を用意、これに各役での点数を格納する。
Boolean配列で `false` なら 0、`true` なら計算（アッパーなら出目の合計値、ロウワーなら固定値もしくは全ダイスの合計値）

### 最終処理

最終的には、`[役名, 点数]` の形で全役分を入れるための多次元配列を用意。
インデックスに対応した役名の配列を用意。
二つの配列をzip関数のように繋げて多次元配列化する。
これをリターンして、関数の処理は完了。

## 前処理

各セクションを鑑みるに、5桁の数値のままにする意味は無さそう。
`toString()` 化するなりで配列に変換した方がいい。

その際、`set` 型も設けて種類と数をわかるように

結果を格納するため、一つの出目に対するスコアカテゴリを管理する配列が必要。
各セクションで条件を満たさないものにfalseをつけていく。

## 役の判定

### アッパーセクション

含まれる数値によるループ処理でよさそう

#### aces

5から、1の要素を消した配列の要素数を引いた値

#### twos

#### threes

#### fours

#### fives

#### sixes

### ローワーセクション

（chanceを除き）種類数に応じて処理を2つに振り分けられそう。

3以下の時はkind系統とFullHouse、4以上はstraight系統

#### chance

無条件で成立

#### three of a kind

種類が3以下、各桁を移動し2回同値である

#### four of a kind

種類が2以下、各桁を移動し3回同値である

#### yahtzee

種類が1

＊ of a kind と纏めて処理できる。
各桁移動の処理を最後まで行い、同値の回数に応じてフラグ立て可能。
この場合、種類によるガード節は不要となる。

#### full house

種類が2、かつ2番目と4番目が異なる数値

#### s_straight

種類が4以上
文字列化したパターン配列を用意、引数を文字列化し両者を比較

#### l_straight

種類が5
文字列化したパターン配列を用意、引数を文字列化し両者を比較

※ straight関係を纏めて処理できる？
l側を先に判定し、これを満たせば無条件でs側を満たす。
l側を満たさないときに初めてs側を判定する。
ガード節で4種類を設ける？
